# Interpreter

Make an interpreter for a simple programming language! Or an interpreter for a small part of a language! The programming language I'll use as an example is `brainfuck`.
Write a program that parses and executes source code from a file.

## Brainfuck
(Copied from http://www.muppetlabs.com/~breadbox/bf/)
> A Brainfuck program has an implicit byte pointer, called "the pointer", which is free to move around within an array of 30000 bytes, initially all set to zero. The pointer itself is initialized to point to the beginning of this array.
> The Brainfuck programming language consists of eight commands, each of which is represented as a single character.

>
    >         Increment the pointer.
    <         Decrement the pointer.
    +         Increment the byte at the pointer.
    -         Decrement the byte at the pointer.
    .         Output the byte at the pointer.
    ,         Input a byte and store it in the byte at the pointer.
    [         Jump forward past the matching ] if the byte at the pointer is zero.
    ]         Jump backward to the matching [ unless the byte at the pointer is zero.

## Basic Instructions
1. Write a lexer. The lexer should convert the source code into tokens, ignoring whitespace and any other characters that are not part of the language.
2. Set up your data structures for the array and the pointer. The array should have a length of 30,000, and the values in the array should always be between 0 and 256. (You might not want to actually store an array of length 30,000.)
3. Write a parser. The parser is where you check for matching "[" and "]".
    a. Create a tree.  Each node in the tree should be a command. "[" nodes should have children corresponding to the commands inside the "[" until its matching "]".
    b. Since the language is so simple, you could skip the tree and instead look through and store the indices of matching "["s to "]"s in a hash table by iterating through the code using a stack. When you encounter a "[", push its index to the stack. When you encounter a "]", pop off the index of the last "[". Add the index of the "[" and the index of the "]" as a key, value pair to the hash map.
4. Execute the code.
    a. If your parser generated a tree, iterate through the nodes and execute the command at that node. For each of the first six commands, the execution is straightforward. To handle the bracket nodes, which act like while loops, you can use recursion to execute their children.
    b. Otherwise, iterate through the tokens generated by the lexer. Execute each token (the first six are easy). When you hit a "[", if the value at the pointer is 0, skip to the corresponding "]" (you can find the index of the corresponding "]" using the hash map you made in step 3). If it's not zero, append the index of the "[" to the stack. Then, when you reach a "]", jump back to the index of the corresponding "]" by popping the last item off the stack (it should be the index of the corresponding "]".
5. Test your interpreter. You can use the Hello World example.

## More Ideas
* Make a REPL for your interpreter
* Write a compiler! User your parser to output code in another language, rather than executing the code directly.

## Resources
* The brainfuck language: http://www.muppetlabs.com/~breadbox/bf/
* Lexical analysis: http://en.wikipedia.org/wiki/Lexical_analysis
* Parsers: http://en.wikipedia.org/wiki/Parse#Computer_languages
* Abstract syntax trees: http://en.wikipedia.org/wiki/Abstract_syntax_tree
* A brainfuck interpreter in Python: http://mpcabd.igeex.biz/brainfuck-python-interpreter/
* Another in Python: http://thevogonpoet.wordpress.com/2012/09/02/writing-a-brainfuck-interpretter-in-python/
* Compiling brainfuck to C: http://blog.justinpoliey.com/transpiling-languages-an-intro-with-brainfuck.html
* Scheme interpreter in 90 lines of Python - I recommend you read this as a general introduction by example to interpreters and compilers. the simple syntax of Scheme makes it easy to follow http://norvig.com/lispy.html
* Mary's Lisp interpreter in JS https://www.hackerschool.com/blog/21-little-lisp-interpreter
